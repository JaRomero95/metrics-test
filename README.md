# Exposed problem

We want a Front-end + Backend application that allows you to post and visualize metrics. Each metric will have a Timestamp, name, and value. The metrics will be shown in a timeline and must show averages per minute/hour/day. The metrics will be persisted in the database.

# Working example

http://51.38.33.155

# Setup

## Backend

- Install ruby 3.1.2
- Install sqlite system dependencies: `sudo apt-get install libsqlite3-dev`
- Clone this repo
- Navigate to the `backend` folder
- Install dependencies: `bundle install`
- `bundle exec rails db:setup`
- `PORT=8000 bundle rails server`

## Frontend

- Install nodejs and npm, preferably 16.15.x
- Clone this repo if it wasn't previously cloned
- Navigate to the `frontend` folder
- Install dependencies: `npm install`
- Run in development mode: `REACT_APP_BASE_URL=http://localhost:8000/ npm start`

*Note** replace REACT_APP_BASE_URL with the URL of the backend service
# Repository

This repository includes backend and frontend separated in folders for simplicity purposes.

# Backend project

The backend was generated by the Rails CLI using two options: *--api* and *--skip-test*. The first is to leave out some gems that we don't need in a Rails API-only project. The second was to avoid installing Minitest, I installed Rspec instead.

## Gems

In addition to the default gems installed in a basic Rails project, I added the following gems:

### rack-cors

Enabled for permit cross-origin requests from the Frontend. The whitelist is a wildcard to simplify the setup in this example project, but should only have allowed the deployed Frontend URL.

### blueprinter

The option to serialize resources to JSON. I usually use a private gem, but I installed it to try something different.

### groupdate

Installed to simplify grouping by dates. The resulted SQL query is identical to the ActiveRecord group API, but this gem made post-processing to fill empty spaces in the selected range.

### factory_bot_rails

Useful for generating test data. Not required in this small project but I like to work with it. I prefer to use factories over seeds for testing because seeds become so complex and huge that only people with experience in the project are able to know and use them. But both methods can work together for integration/e2e tests when the test setup becomes big if we use only factories.

The problem with factories is the performance, we should be cautious when creating resources in the database in the test environment because that is the slowest part of a test suite. Building instead of creating objects, replacing models with plain objects or mock services responses to avoid triggering extra queries in integration tests are some practices we can do to improve times.

### faker

It helps to generate fake data, especially inside factories but can be used in other places. As the factory_bot gem, is not necessary for this project, but is very useful in any project and it does not affect the performance in production because is only for development/testing, so I usually add it to the Gemfile.

### rspec-rails

The test framework I use always to replacing Minitest.

### rubocop-rails

Linter for ensuring consistency in writing Ruby code.

### simplecov

Necessary to check the code coverage after executing the tests. While having a 100% is not mandatory because we don't need to be obsessed to test everything, especially with application setup files and other special code, we should put attention to the coverage of all the new features and achieve to execute all the new lines that we are writing in our code. If we are following TDD, will achieve this without thinking about it.

## Database engine

The database chosen for this project is SQLite. This project is simple enough to be backed by any database engine but to avoid setting up another service for the database, I let SQLite.

## Schema

The schema is very simple. It consists of a single *Metric* table because is the only data that we need to store. It includes the timestamps autogenerated by ActiveRecord plus the 3 fields required.

## Repository pattern and project architecture

In this project, I used a service class for query/persist the Metric model. The base ApplicationRepository is very basic and is lacking required methods like `find` or `update` that weren't necessary for this simple project.

It is only a prototype, and it works in conjunction with other key decisions to achieve the following points:

- Avoid spread queries through all files using the Repository as an intermediary.
- This reduces coupling in the App with ActiveRecord and the database engine. Centralization of queries helps us to maintain queries or even change the database engine without so much pain.
- Easier to test other services that need to query the database. Mocking the repository is better than trying to mock several ActiveRecord methods. And tests become faster avoiding queries.

In addition to the repositories, I took another important decision: make the models thin. Models in an RoR application tend to grow and become huge and hard to maintain. ActiveRecord becomes a pain when we work with big models, making changes difficult to track, introducing unexpected dependencies between resources and creating performance problems.

ActiveRecord is as powerful as dangerous. Leaving the models flat we avoid a lot of troubles in the future. Models should have only simple validations and basic scopes. Later the repository will take advantage of those scopes to build the queries necessary for real scenarios.

ActiveRecord callbacks disappear from the models. We will create independent services for making actions with the resources. In this project, because we have only a simple create action, I did not develop a service over it, but the idea of this architecture is to have a wrapper over all the actions, reusable in other places. Those services will run other actions after saving a resource if necessary, like a callback, but in a more declarative and easy-to-maintain way.

## User system

The exposed problem doesn't specify anything about a users system, so I took the decision of not develop one because it add extra work but not real complexity.

I usually work with an authentication system based on JWT. The token is added to the headers of every authenticated request because REST APIs have no session information, so the token is always required.

As special cases, I worked in a project with registration/login through LDAP using the gem https://rubygems.org/gems/net-ldap but I can't show that code.

In this other personal project from some years ago, I was using Google as the provider for the users system through the Firebase interface in a backend-less app. It is not working anymore: https://github.com/JaRomero95/fritaim-app/blob/master/src/components/login/Login.js

This other personal project used Trello API as backend, so authentication is using his users system: https://github.com/JaRomero95/todo-groups/blob/53e438c34eb502b86a73071e7339d67603964ff6/src/pages/Login.vue

## Backend testing strategies

I followed different strategies depending on what I was testing. Some tests are units, others integrate more services.

### Models specs

For model specs, I tested validations and scopes. The idea of this architecture is to have flat models, so we don't have so many things to test here.

I avoid common model tests in the Rails community for fields and relations. In my opinion, they don't add value. If a field is important, would be other tests to check that feature. Fields/associations tests are very similar to the model definition, generally written with a copy&paste as the base.

For validations, I avoid gems that include the same type of "fast" matchers over ActiveModel::Validations. I prefer to do validation tests manually with a small and clear setup. Those matchers are another copy&paste over model validations so developers don't think about which tests they need, they simply copy the content from the model to the spec and change a few characters.

And finally, for scopes, I like to make tests with real data from the database. Scopes are queries to the database engine and can introduce bugs easily with queries that don't work like we expected if we mock this behaviour. The only way to feel safe about the queries is by running them.

In the scope tests, as it should be in any other spec, I test edge cases, one case under the criteria, one in the middle and one more over the criteria.

### Repositories specs

These are also not unit tests because they query directly the database. For the same reason that the scope tests in the model spec, I think that the only way that we can trust our query methods is by running them instead of doing mocks.

### Requests specs

These are a combination between an integration test and a unit test. Rspec defines them as integration tests and gives us the ability to check the full stack, but I mock the services used here to make them faster and avoid bigger setups and re-test services that have full coverage.

Mocking those services barely reduces the confidence that these specs give us because the mocked services are fully tested and have a small public interface. Thanks to making controllers thin, they are very easy to test and the specs are fast to execute.

I like to test the URLs, avoiding the url helpers provided by Rspec and writing it manually to avoid mistakes using with the routing DSL provided by Rails.

For generic situations in controllers, I like to create generic shared examples that simplify the testing of some aspects. For example `it_behaves_like 'an authenticated action'` or `it_behaves_like 'a paginable index'` that infers data from the example and permits some params to be more adaptable to different controllers.

An example of this:

```ruby
RSpec.shared_examples 'authenticated action' do |params|
  http_method = params.fetch(:http_method, :get)

  before do
    method(http_method).call(path, params: params)
  end

  it 'returns 401 Http status code' do
    expect(response).to have_http_status(401)
  end
end
```

### Services specs

In the example in this project, I mocked the repository to avoid running queries to the database, so the tests are fast and I only test calls to the repository which has a well tested interface.

# Frontend project

Frontend was generated with **Create React App** using the template that includes TypeScript.

## Frontend libraries

### Material UI

The component library reduces the work on common components and CSS adding material design styles out of the box.

### Axios

To simplify communication with the backend API, easier to use than the JS fetch API.

### Chart.js

Assembles the linear chart that we can see in this project.

### Qs

It helps me manage query params, especially when they have more than one level, such as index filters for metrics: `/group_metrics?filter[datetime_from]=2022-06-25T22:25&filter[datetime_until]=2022-07-05T22:26`

### React i18next

For handling messages to avoid writing translations directly in the components.

### Styled components

To add **scoped** css styles in components

## Frontend testing strategies

I did not take the time to create tests for the frontend side of the application, but I can show other examples I developed previously.

The idea was to add unit tests for components and other javascript code, and e2e tests with Cypress.

As an example, I have this project I did in the past, where I have unit tests for multiple types of files:

https://github.com/JaRomero95/calendar/tree/master/client/src/spec

For e2e tests I have examples in Ruby with Capybara:

https://github.com/JaRomero95/calendar/tree/master/spec/features

And other examples with Cypress:

https://github.com/JaRomero95/todo-groups/tree/master/tests/e2e/specs

### Component unit tests

First of all, I like to do simple component snapshot tests. It helps me to track unexpected changes in components when I refactor a component without trying to change its output. They aren't tests that add much value but they are worth it because are easy to write and maintain.

The next is to test the component behaviour. I avoid focusing on component methods or any internal details. For tests the components I use shallow mounts, rarely or never complete mount because they are hard to maintain and they test other behaviours more complex than we can cover with e2e tests.

The tests I make for a component are the followings:

- Render result with default/minimal props.
- Props sent to children.
- Changes in elements rendered with specific props
- Simulation of events to spy what injected methods by props or other external services are called. All functions received by props are jest mocks to facilitate this task.

So the main idea is to test input (props, events) and output (render, external services calls), never internal methods on any other intermediate step.

Example testing children props and simulating events: https://github.com/JaRomero95/calendar/blob/master/client/src/spec/components/events/EventModalShow.spec.js

Other modules are easier to test because they are plain javascript files not related to React. For example, a unit test of a small JS service to calculate date ranges:

https://github.com/JaRomero95/calendar/blob/master/client/src/spec/lib/dateRangeCalculator.spec.js

I have more examples from other parts of a React App, for example, a Redux store:

https://github.com/JaRomero95/calendar/tree/master/client/src/spec/store/modules/events

In this case, a redux store, the actions, reducers and selectors are easy to test because they are plain javascript, but with Redux saga I followed an integration approach, focusing more on the actions triggered than in test step by step the actions produced, thanks to this package: https://github.com/jfairbank/redux-saga-test-plan

### E2E with Capybara

These tests are mounting in the Rails application. They build the frontend and test it using a headless Chrome making real requests to the backend in a test environment.

We have available the Rails stack so we can use tools like FactoryBot, DatabaseCleaner and even mock directly some classes if it is necessary. It is easy to create a controlled environment for testing our frontend application end-to-end in this way.

It is necessary to have special care for the performance of these tests because they need more time and resources than any other type of test. For that reason, I used rspec-longrun to split examples into steps, avoiding setting up clean scenarios for small expectations, but maintaining in some way the maintainability and readability of small examples.

Here we have a full example of a spec of a form page: https://github.com/JaRomero95/calendar/blob/master/spec/features/update_event_spec.rb

### E2E with Cypress

In another personal project, I chose this JavaScript framework to develop the e2e tests. In this case, the scenario is different: I don't have any more full control over the backend, and it is not running during the tests.

For this reason, I needed to mock the server responses and luckily Cypress has the tools to do that. I created different [jsons](https://github.com/JaRomero95/todo-groups/blob/master/tests/e2e/fixtures/boards/board.json) to mock the responses of the Trello API to simulate the service in the test environment.

Tests here are similar to the Capybara tests mentioned above, but without the data setup that now belongs to the fixture json files.

Example: https://github.com/JaRomero95/todo-groups/blob/master/tests/e2e/specs/tasks/create.js

## State management

The project is too small so it does not require a package for state management, the local state in components was enough to handle the problem.

In other projects, I used other solutions to handle the App store:

### Vuex

https://github.com/JaRomero95/todo-groups/blob/master/src/services/store/modules/board.js

### Redux
Store: https://github.com/JaRomero95/calendar/tree/master/client/src/store

Store module example (following [re-duck](https://github.com/alexnm/re-ducks) pattern): https://github.com/JaRomero95/calendar/tree/master/client/src/store/modules/events

Redux sagas example: https://github.com/JaRomero95/calendar/blob/master/client/src/store/modules/events/sagas.js

### Mobx + API Context
Store example: https://github.com/JaRomero95/english-platform/blob/master/client/src/store/UserStore.tsx

Basic context provider for store: https://github.com/JaRomero95/english-platform/blob/master/client/src/providers/UserStoreContext.tsx

Adding providers: https://github.com/JaRomero95/english-platform/blob/master/client/src/App.tsx

## React Router

This project has only one page so it does not require a routing solution. I used React Router and the similar Vue Router in other projects.

A React Router 6+ example (not the best one): https://github.com/JaRomero95/english-platform/blob/master/client/src/router/AppRoutes.tsx

## Wrapping third party components

As we should do with any other third-party package when we code both backend and frontend, I wrapped components used from the MaterialUI package in other components that belong to the project.

In the components folder inside the frontend project, there are some components with an `App` prefix. These are generic components that sometimes wrap MaterialUI components.

With those components wrapped, is easier to maintain the project because we avoid spreading third-party components through the app. Styles are more consistent in this way because we reuse the same template in all places, and if we have breaking changes updating the package, we only need to update one component to fix the errors.

## Components organization

In this project, I put all the components in the same folder called `components`. In bigger projects, I used to create a folder for each namespace, for example, `metrics`, with all the components related to these features, and a `general` folder for components prefixed with `App`.

Also, I have the `pages` folder where we can find components that are top-level in the router. These "page" components compound the pages using more specific components.

# Performance

There are some points that affect the performance of this project:

- The GroupMetricsService, which uses the repository, made only one optimized query to get the result. Filter, group and average actions are made in the same query so we avoid fetching a lot of items and post-processing them to calculate the average.
- There is not an index action over the Metric model directly so we did not include N+1 problems.
- GroupMetricsController has no limitations. This is a real performance problem, especially when we query for wide ranges with a small unit for grouping like minutes. It generates a lot of sections and it is a problem for the performance and stability. The way to resolve the problem here is to validate the requested range before running the query and putting a limit to it. The lower the unit, the more sections we have for the same range, so we need to validate both together. A service for watch metrics like DataDog selects automatically the appropriate time unit to group the results based on the dimension of the period selected.
- The frontend can become slow when there is too much data to show in the chart, so the same validation we talked about in the backend will help to avoid performance problems in the frontend.

# Docker

I did not include a Dockerfile or docker-compose to build this project, but I used Docker to build some containers in other projects. You can check here an old `docker-compose.yml` for a similar project Rails + React + PostgresSQL I developed in the past:

https://github.com/JaRomero95/calendar/blob/master/docker-compose.yml

```yaml
version: '3'
services:
  db:
    image: postgres
    volumes:
      - ./tmp/db:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  app:
    build: .
    command: bash -c "rm -f tmp/pids/server.pid && bundle exec rails s -p 3000 -b '0.0.0.0'"
    volumes:
      - .:/app
      - ./client:/app/client
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      CLIENT_BASE_URL: ${CLIENT_BASE_URL}
      CLIENT_PORT: ${CLIENT_PORT}
    ports:
      - "${API_PORT}:3000"
    depends_on:
      - db
  client:
    stdin_open: true
    build:
      context: ./client/
    command: yarn start
    volumes:
      - ./client:/app
      - ./client/node_modules:/app/node_modules
    environment:
      REACT_APP_API_BASE_URL: ${API_BASE_URL}
      REACT_APP_API_PORT: ${API_PORT}
    ports:
      - "${CLIENT_PORT}:3000"
```
